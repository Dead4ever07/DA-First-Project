<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: src/libs/RouteSearch.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_87a455bccb09a92130c26a11a880c98a.html">libs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">RouteSearch.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Graph_8h_source.html">Graph.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for RouteSearch.h:</div>
<div class="dyncontent">
<div class="center"><img src="RouteSearch_8h__incl.png" border="0" usemap="#asrc_2libs_2RouteSearch_8h" alt=""/></div>
<map name="asrc_2libs_2RouteSearch_8h" id="asrc_2libs_2RouteSearch_8h">
<area shape="rect" title=" " alt="" coords="151,5,318,31"/>
<area shape="rect" href="Graph_8h.html" title=" " alt="" coords="198,79,271,104"/>
<area shape="poly" title=" " alt="" coords="237,31,237,65,232,65,232,31"/>
<area shape="rect" title=" " alt="" coords="5,152,85,177"/>
<area shape="poly" title=" " alt="" coords="205,107,90,149,88,144,203,102"/>
<area shape="rect" title=" " alt="" coords="294,225,357,251"/>
<area shape="poly" title=" " alt="" coords="208,106,182,120,159,137,146,156,146,166,150,176,177,201,211,218,247,228,281,233,280,238,246,233,209,223,174,206,146,179,140,167,141,155,155,133,180,115,206,102"/>
<area shape="rect" title=" " alt="" coords="161,152,223,177"/>
<area shape="poly" title=" " alt="" coords="230,106,208,142,204,139,225,103"/>
<area shape="rect" title=" " alt="" coords="248,152,307,177"/>
<area shape="poly" title=" " alt="" coords="244,103,266,139,261,142,239,106"/>
<area shape="rect" title=" " alt="" coords="331,152,416,177"/>
<area shape="poly" title=" " alt="" coords="258,102,340,143,337,148,256,106"/>
<area shape="rect" href="MutablePriorityQueue_8h.html" title=" " alt="" coords="440,152,616,177"/>
<area shape="poly" title=" " alt="" coords="272,99,468,146,467,151,271,104"/>
<area shape="poly" title=" " alt="" coords="496,180,371,224,369,219,495,175"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="RouteSearch_8h__dep__incl.png" border="0" usemap="#asrc_2libs_2RouteSearch_8hdep" alt=""/></div>
<map name="asrc_2libs_2RouteSearch_8hdep" id="asrc_2libs_2RouteSearch_8hdep">
<area shape="rect" title=" " alt="" coords="5,5,172,31"/>
<area shape="rect" href="Menu_8h.html" title=" " alt="" coords="29,79,149,104"/>
<area shape="poly" title=" " alt="" coords="91,44,91,79,86,79,86,44"/>
</map>
</div>
</div>
<p><a href="RouteSearch_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0df9ebd22e14dd2e37db59cc2f760d5b" id="r_a0df9ebd22e14dd2e37db59cc2f760d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#a0df9ebd22e14dd2e37db59cc2f760d5b">getWalkRoute</a> (<a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *g, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *<a class="el" href="classEdge.html">middle</a>, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *dest, <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classEdge.html">int</a> &gt; &amp;<a class="el" href="classEdge.html">route</a>, <a class="el" href="classEdge.html">int</a> &amp;<a class="el" href="classEdge.html">cost</a>)</td></tr>
<tr class="memdesc:a0df9ebd22e14dd2e37db59cc2f760d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the driving-walking route from the destination to the origin based on the shortest path computed.  <br /></td></tr>
<tr class="separator:a0df9ebd22e14dd2e37db59cc2f760d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa059527e092534cc62b3c2d53f7c4be8" id="r_aa059527e092534cc62b3c2d53f7c4be8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#aa059527e092534cc62b3c2d53f7c4be8">getDriveRoute</a> (<a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *g, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *<a class="el" href="classEdge.html">origin</a>, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *dest, <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classEdge.html">int</a> &gt; &amp;<a class="el" href="classEdge.html">route</a>, <a class="el" href="classEdge.html">int</a> &amp;<a class="el" href="classEdge.html">cost</a>, <a class="el" href="classEdge.html">bool</a> <a class="el" href="classEdge.html">toSelect</a>, <a class="el" href="classEdge.html">bool</a> <a class="el" href="classEdge.html">firstPath</a>)</td></tr>
<tr class="memdesc:aa059527e092534cc62b3c2d53f7c4be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the driving route from the destination to the origin based on the shortest path computed.  <br /></td></tr>
<tr class="separator:aa059527e092534cc62b3c2d53f7c4be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293841dc2d91eed2e54107ac150c2fe7" id="r_a293841dc2d91eed2e54107ac150c2fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#a293841dc2d91eed2e54107ac150c2fe7">getPath</a> (<a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *g, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *<a class="el" href="classEdge.html">origin</a>, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *dest, <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classEdge.html">int</a> &gt; &amp;<a class="el" href="classEdge.html">route</a>, <a class="el" href="classEdge.html">int</a> &amp;<a class="el" href="classEdge.html">cost</a>, <a class="el" href="classEdge.html">bool</a> <a class="el" href="classEdge.html">toSelect</a>, <a class="el" href="classEdge.html">bool</a> <a class="el" href="classEdge.html">firstPath</a>)</td></tr>
<tr class="memdesc:a293841dc2d91eed2e54107ac150c2fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the shortest path from origin to destination using Dijkstra's algorithm.  <br /></td></tr>
<tr class="separator:a293841dc2d91eed2e54107ac150c2fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0711b51345ef1267d243a5fddad3bd7c" id="r_a0711b51345ef1267d243a5fddad3bd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#a0711b51345ef1267d243a5fddad3bd7c">printRoute</a> (<a class="el" href="classEdge.html">const</a> <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classEdge.html">int</a> &gt; &amp;<a class="el" href="classEdge.html">route</a>, <a class="el" href="classEdge.html">int</a> <a class="el" href="classEdge.html">routeCost</a>)</td></tr>
<tr class="separator:a0711b51345ef1267d243a5fddad3bd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7278b18d7065b52ffc7fa359f1a6ab72" id="r_a7278b18d7065b52ffc7fa359f1a6ab72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#a7278b18d7065b52ffc7fa359f1a6ab72">driveRoute</a> (<a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *g, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *<a class="el" href="classEdge.html">origin</a>, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *dest)</td></tr>
<tr class="memdesc:a7278b18d7065b52ffc7fa359f1a6ab72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the shortest driving route between two vertices using Dijkstra’s algorithm. It also attempts to find an alternative route, if possible.  <br /></td></tr>
<tr class="separator:a7278b18d7065b52ffc7fa359f1a6ab72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f59963f85e4f72071fe928cf611854" id="r_ad1f59963f85e4f72071fe928cf611854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#ad1f59963f85e4f72071fe928cf611854">driveRestrictedRoute</a> (<a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *g, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *<a class="el" href="classEdge.html">origin</a>, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *dest, <a class="el" href="classEdge.html">const</a> <a class="el" href="classEdge.html">int</a> &amp;<a class="el" href="classEdge.html">middle</a>)</td></tr>
<tr class="memdesc:ad1f59963f85e4f72071fe928cf611854"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the shortest restricted driving route between two vertices using Dijkstra’s algorithm.  <br /></td></tr>
<tr class="separator:ad1f59963f85e4f72071fe928cf611854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044ff85d251d6d671fef78cad7e04c3a" id="r_a044ff85d251d6d671fef78cad7e04c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#a044ff85d251d6d671fef78cad7e04c3a">driveWalkingPath</a> (<a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; * &gt; &amp;<a class="el" href="classEdge.html">parkingSpots</a>, <a class="el" href="classEdge.html">int</a> &amp;<a class="el" href="classEdge.html">distance</a>)</td></tr>
<tr class="memdesc:a044ff85d251d6d671fef78cad7e04c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the optimal parking spot based on the shortest combined driving and walking distance.  <br /></td></tr>
<tr class="separator:a044ff85d251d6d671fef78cad7e04c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3304f73c4bf8c20a686149f890da954a" id="r_a3304f73c4bf8c20a686149f890da954a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::pair</a>&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#a3304f73c4bf8c20a686149f890da954a">driveWalkingPaths</a> (<a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; * &gt; &amp;<a class="el" href="classEdge.html">parkingSpots</a>, <a class="el" href="classEdge.html">int</a> &amp;<a class="el" href="classEdge.html">distance1</a>, <a class="el" href="classEdge.html">int</a> &amp;<a class="el" href="classEdge.html">distance2</a>)</td></tr>
<tr class="memdesc:a3304f73c4bf8c20a686149f890da954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the two best parking spots for a drive-walk route based on distance and eco-friendliness.  <br /></td></tr>
<tr class="separator:a3304f73c4bf8c20a686149f890da954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff33a6dab7ff67a0cef2668ca3c781f" id="r_afff33a6dab7ff67a0cef2668ca3c781f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#afff33a6dab7ff67a0cef2668ca3c781f">printWalkingDrivingRoute</a> (<a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *g, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *<a class="el" href="classEdge.html">origin</a>, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *<a class="el" href="classEdge.html">parkingVertex</a>, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *dest, <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> <a class="el" href="classEdge.html">numRoute</a>, <a class="el" href="classEdge.html">int</a> <a class="el" href="classEdge.html">distance</a>)</td></tr>
<tr class="memdesc:afff33a6dab7ff67a0cef2668ca3c781f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a combined driving-walking route from origin to destination, including a parking spot.  <br /></td></tr>
<tr class="separator:afff33a6dab7ff67a0cef2668ca3c781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c7c4d0c7a36cdd5df1c6006c1184c6" id="r_ae9c7c4d0c7a36cdd5df1c6006c1184c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#ae9c7c4d0c7a36cdd5df1c6006c1184c6">approximateSolution</a> (<a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *g, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *<a class="el" href="classEdge.html">origin</a>, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *dest, <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; * &gt; <a class="el" href="classEdge.html">parkingSpots</a>)</td></tr>
<tr class="memdesc:ae9c7c4d0c7a36cdd5df1c6006c1184c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an approximate driving-walking route when an exact solution isn't available.  <br /></td></tr>
<tr class="separator:ae9c7c4d0c7a36cdd5df1c6006c1184c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b3b14654cf4c556851c40260beefe" id="r_a421b3b14654cf4c556851c40260beefe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="RouteSearch_8h.html#a421b3b14654cf4c556851c40260beefe">driveWalkingRoute</a> (<a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *g, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *<a class="el" href="classEdge.html">origin</a>, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *dest, <a class="el" href="classEdge.html">const</a> <a class="el" href="classEdge.html">int</a> &amp;<a class="el" href="classEdge.html">max</a>)</td></tr>
<tr class="memdesc:a421b3b14654cf4c556851c40260beefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best driving and walking route given a maximum walking distance constraint.  <br /></td></tr>
<tr class="separator:a421b3b14654cf4c556851c40260beefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae9c7c4d0c7a36cdd5df1c6006c1184c6" name="ae9c7c4d0c7a36cdd5df1c6006c1184c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c7c4d0c7a36cdd5df1c6006c1184c6">&#9670;&#160;</a></span>approximateSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> approximateSolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>parkingSpots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an approximate driving-walking route when an exact solution isn't available. </p>
<p>This function attempts to find up to two parking spots that minimize the total travel distance and generates two routes, if possible. First, it Identifies the two closest parking spots using <a class="el" href="RouteSearch_8h.html#a3304f73c4bf8c20a686149f890da954a" title="Determines the two best parking spots for a drive-walk route based on distance and eco-friendliness.">driveWalkingPaths()</a>. If there are two valid parking spots, it generates both routes using <a class="el" href="RouteSearch_8h.html#afff33a6dab7ff67a0cef2668ca3c781f" title="Formats a combined driving-walking route from origin to destination, including a parking spot.">printWalkingDrivingRoute()</a>. If no valid parking spots are available, it returns an error message for each try.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph representing the road network. </td></tr>
    <tr><td class="paramname">origin</td><td>Pointer to the origin vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination vertex. </td></tr>
    <tr><td class="paramname">parkingSpots</td><td>List of available parking spots in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string containing the approximate driving-walking route(s).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O((V + E)log V) due to searching for parking spots and generating routes requires using Dijkstra's algorithm. </dd></dl>

</div>
</div>
<a id="ad1f59963f85e4f72071fe928cf611854" name="ad1f59963f85e4f72071fe928cf611854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f59963f85e4f72071fe928cf611854">&#9670;&#160;</a></span>driveRestrictedRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> driveRestrictedRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">const</a> <a class="el" href="classEdge.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>middle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the shortest restricted driving route between two vertices using Dijkstra’s algorithm. </p>
<p>This function computes the best driving route from an origin to a destination origin vertex to a destination vertex, while considering an optional middle vertex. If no middle vertex is specified, it finds the shortest driving route by calling <a class="el" href="RouteSearch_8h.html#a293841dc2d91eed2e54107ac150c2fe7" title="Retrieves the shortest path from origin to destination using Dijkstra&#39;s algorithm.">getPath()</a>. If a middle vertex is provided, it ensures that the route passes through it. The computed route and its cost are formatted into a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">origin</td><td>Pointer to the starting vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination vertex. </td></tr>
    <tr><td class="paramname">middle</td><td>The ID of the middle vertex that must be included in the route (-1 if not required). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string containing the restricted driving route and its cost. If no route is found, "none" is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O((V + E)log V) due to Dijkstra’s algorithm being used within <a class="el" href="RouteSearch_8h.html#a293841dc2d91eed2e54107ac150c2fe7" title="Retrieves the shortest path from origin to destination using Dijkstra&#39;s algorithm.">getPath()</a>. </dd></dl>

</div>
</div>
<a id="a7278b18d7065b52ffc7fa359f1a6ab72" name="a7278b18d7065b52ffc7fa359f1a6ab72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7278b18d7065b52ffc7fa359f1a6ab72">&#9670;&#160;</a></span>driveRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> driveRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the shortest driving route between two vertices using Dijkstra’s algorithm. It also attempts to find an alternative route, if possible. </p>
<p>This function computes the best driving route from an origin vertex to a destination vertex. It first calls <a class="el" href="RouteSearch_8h.html#a293841dc2d91eed2e54107ac150c2fe7" title="Retrieves the shortest path from origin to destination using Dijkstra&#39;s algorithm.">getPath()</a> to determine the shortest path. If a path is found the function attempts to find an alternative route by calling <a class="el" href="RouteSearch_8h.html#a293841dc2d91eed2e54107ac150c2fe7" title="Retrieves the shortest path from origin to destination using Dijkstra&#39;s algorithm.">getPath()</a> again. If no alternative route is found, it appends "none" to the result. Otherwise, it formats and adds the alternative route.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">origin</td><td>Pointer to the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string containing the best and alternative routes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O((V + E)log V) since it calls <a class="el" href="RouteSearch_8h.html#a293841dc2d91eed2e54107ac150c2fe7" title="Retrieves the shortest path from origin to destination using Dijkstra&#39;s algorithm.">getPath()</a> which executes <a class="el" href="DijkstraFunctions_8h.html#a499e2217711f5ce50203011d3d6dbd88" title="Implements Dijkstra&#39;s algorithm to find the shortest path.">dijkstra()</a>. </dd></dl>

</div>
</div>
<a id="a044ff85d251d6d671fef78cad7e04c3a" name="a044ff85d251d6d671fef78cad7e04c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044ff85d251d6d671fef78cad7e04c3a">&#9670;&#160;</a></span>driveWalkingPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; * driveWalkingPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>parkingSpots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the optimal parking spot based on the shortest combined driving and walking distance. </p>
<p>This function iterates through a list of parking spots and selects the one that minimizes the total distance, which is the sum of the driving distance (getDist()) and the walking distance (getForwardDist()). If two parking spots have the same total distance, the one with the shorter driving distance is preferred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parkingSpots</td><td>A vector containing pointers to potential parking spot vertices. </td></tr>
    <tr><td class="paramname">distance</td><td>Reference to an integer storing the minimum found total distance. It gets updated to the best-found distance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the optimal parking vertex. If no parking spot is found, returns nullptr.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O(N), where N is the number of parking spots in the vector. </dd></dl>

</div>
</div>
<a id="a3304f73c4bf8c20a686149f890da954a" name="a3304f73c4bf8c20a686149f890da954a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3304f73c4bf8c20a686149f890da954a">&#9670;&#160;</a></span>driveWalkingPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::pair</a>&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; * &gt; driveWalkingPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>parkingSpots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>distance1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>distance2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the two best parking spots for a drive-walk route based on distance and eco-friendliness. </p>
<p>This function iterates through a list of potential parking spots and selects the two best options in terms of total distance (driving + walking). If two parking spots have the same total distance, the one with the shorter driving distance is preferred (considered more eco-friendly). In the end, distance1 and distance2 have the total distances for the best and second-best parking spots, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parkingSpots</td><td>A vector containing pointers to candidate parking vertices. </td></tr>
    <tr><td class="paramname">distance1</td><td>Reference to an integer storing the total distance to the best parking spot. </td></tr>
    <tr><td class="paramname">distance2</td><td>Reference to an integer storing the total distance to the second-best parking spot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of pointers to the best and second-best parking vertices, respectively.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O(N), where N is the number of parking spots and ach vertex is checked once. </dd></dl>

</div>
</div>
<a id="a421b3b14654cf4c556851c40260beefe" name="a421b3b14654cf4c556851c40260beefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421b3b14654cf4c556851c40260beefe">&#9670;&#160;</a></span>driveWalkingRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> driveWalkingRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">const</a> <a class="el" href="classEdge.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best driving and walking route given a maximum walking distance constraint. </p>
<p>This function first calls <a class="el" href="DijkstraFunctions_8h.html#a16adf7b38176d619ebf07defab951b69" title="Implements Dijkstra&#39;s algorithm to find the shortest path, but uses the relaxWalking() function to up...">dijkstraWalking()</a> with the destination to compute the shortest walking distances from all potential parking spots. It then filters parking spots into parkingSpots, which contains all available parking spots and requirementParkingSpots, which only contains the parking spots that are within the given max walking distance. If no parking spots are within the max walking distance, an approximate solution is returned. Otherwise, the best parking spot is selected using <a class="el" href="RouteSearch_8h.html#a044ff85d251d6d671fef78cad7e04c3a" title="Finds the optimal parking spot based on the shortest combined driving and walking distance.">driveWalkingPath()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph representing the road network. </td></tr>
    <tr><td class="paramname">origin</td><td>Pointer to the starting vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination vertex. </td></tr>
    <tr><td class="paramname">max</td><td>The maximum allowed walking time from the parking spot to the destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string describing the best possible route.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O((V + E)log V) due to Dijkstra’s algorithm being used within <a class="el" href="DijkstraFunctions_8h.html#a16adf7b38176d619ebf07defab951b69" title="Implements Dijkstra&#39;s algorithm to find the shortest path, but uses the relaxWalking() function to up...">dijkstraWalking()</a>. </dd></dl>

</div>
</div>
<a id="aa059527e092534cc62b3c2d53f7c4be8" name="aa059527e092534cc62b3c2d53f7c4be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa059527e092534cc62b3c2d53f7c4be8">&#9670;&#160;</a></span>getDriveRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html">void</a> getDriveRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classEdge.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">bool</a>&#160;</td>
          <td class="paramname"><em>toSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">bool</a>&#160;</td>
          <td class="paramname"><em>firstPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the driving route from the destination to the origin based on the shortest path computed. </p>
<p>This function traces back the shortest path from the destination to the origin using the path set by <a class="el" href="DijkstraFunctions_8h.html#a499e2217711f5ce50203011d3d6dbd88" title="Implements Dijkstra&#39;s algorithm to find the shortest path.">dijkstra()</a>. It stores the sequence of vertex IDs in the route vector and accumulates the total driving cost. If the function is being used for non-restricted driving paths (toSelect flag is enable), it marks visited vertices as selected to prevent them from being reused in the alternative route.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">origin</td><td>Pointer to the starting vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination vertex. </td></tr>
    <tr><td class="paramname">route</td><td>Reference to a vector that will store the sequence of vertex IDs in the computed path. </td></tr>
    <tr><td class="paramname">cost</td><td>Reference to an integer that will store the total cost of the computed path. </td></tr>
    <tr><td class="paramname">toSelect</td><td>Boolean flag indicating whether to mark the vertices and edges in the path as selected (to avoid using it in the alternative route). </td></tr>
    <tr><td class="paramname">firstPath</td><td>Boolean flag indicating whether this is the first path being computed (to avoid duplicate selections when including a node).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O(V) since it traces back through at most all vertices in the path. </dd></dl>

</div>
</div>
<a id="a293841dc2d91eed2e54107ac150c2fe7" name="a293841dc2d91eed2e54107ac150c2fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293841dc2d91eed2e54107ac150c2fe7">&#9670;&#160;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html">bool</a> getPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classEdge.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">bool</a>&#160;</td>
          <td class="paramname"><em>toSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">bool</a>&#160;</td>
          <td class="paramname"><em>firstPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the shortest path from origin to destination using Dijkstra's algorithm. </p>
<p>This function is responsible for retrieving the shortest path computed by Dijkstra’s algorithm. It first calls <a class="el" href="DijkstraFunctions_8h.html#a499e2217711f5ce50203011d3d6dbd88" title="Implements Dijkstra&#39;s algorithm to find the shortest path.">dijkstra()</a> to check if there are paths are available, from the origin to the destination. If no path exists it returns false, otherwise, it retrieves the computed route and cost using <a class="el" href="RouteSearch_8h.html#aa059527e092534cc62b3c2d53f7c4be8" title="Constructs the driving route from the destination to the origin based on the shortest path computed.">getDriveRoute()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">origin</td><td>Pointer to the starting vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination vertex. </td></tr>
    <tr><td class="paramname">route</td><td>Reference to a vector that will store the sequence of vertex IDs in the computed path. </td></tr>
    <tr><td class="paramname">cost</td><td>Reference to an integer that will store the total cost of the computed path. </td></tr>
    <tr><td class="paramname">toSelect</td><td>Boolean flag indicating whether to mark the vertices and edges as selected (to avoid using it in the alternative route). </td></tr>
    <tr><td class="paramname">firstPath</td><td>Boolean flag indicating whether this is the first path being computed (to avoid duplicate selections when including a node). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a valid path is found, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O((V + E)log V), since it calls <a class="el" href="DijkstraFunctions_8h.html#a499e2217711f5ce50203011d3d6dbd88" title="Implements Dijkstra&#39;s algorithm to find the shortest path.">dijkstra()</a>. </dd></dl>

</div>
</div>
<a id="a0df9ebd22e14dd2e37db59cc2f760d5b" name="a0df9ebd22e14dd2e37db59cc2f760d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df9ebd22e14dd2e37db59cc2f760d5b">&#9670;&#160;</a></span>getWalkRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html">void</a> getWalkRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classEdge.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the driving-walking route from the destination to the origin based on the shortest path computed. </p>
<p>This function traces back the shortest walking path from the middle vertex (parkingVertex) to the destination, using the path set by <a class="el" href="DijkstraFunctions_8h.html#a16adf7b38176d619ebf07defab951b69" title="Implements Dijkstra&#39;s algorithm to find the shortest path, but uses the relaxWalking() function to up...">dijkstraWalking()</a>. It stores the sequence of vertex IDs in the route vector and accumulates the total driving cost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">middle</td><td>Pointer to the vertex where the walking route starts. </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination vertex. </td></tr>
    <tr><td class="paramname">route</td><td>Reference to a vector storing the sequence of vertex IDs in the walking path. </td></tr>
    <tr><td class="paramname">cost</td><td>Reference to an integer storing the total walking cost.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O(V) since it traces back through at most all vertices in the path. </dd></dl>

</div>
</div>
<a id="a0711b51345ef1267d243a5fddad3bd7c" name="a0711b51345ef1267d243a5fddad3bd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0711b51345ef1267d243a5fddad3bd7c">&#9670;&#160;</a></span>printRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> printRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEdge.html">const</a> <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::vector</a>&lt; <a class="el" href="classEdge.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">int</a>&#160;</td>
          <td class="paramname"><em>routeCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function generates a formatted string with the expected result</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">route</td><td>Vector of vertex IDs representing the computed route. </td></tr>
    <tr><td class="paramname">routeCost</td><td>The total cost of the computed route. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string representing the route.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O(N), where N is the number of nodes in the route. </dd></dl>

</div>
</div>
<a id="afff33a6dab7ff67a0cef2668ca3c781f" name="afff33a6dab7ff67a0cef2668ca3c781f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff33a6dab7ff67a0cef2668ca3c781f">&#9670;&#160;</a></span>printWalkingDrivingRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> printWalkingDrivingRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>parkingVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html#a5263d3883fe8a56539e371f79ff09efb">std::string</a>&#160;</td>
          <td class="paramname"><em>numRoute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">int</a>&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a combined driving-walking route from origin to destination, including a parking spot. </p>
<p>This function first determines the driving route from the origin to the selected parking spot and then computes the walking route from the parking spot to the destination. The resulting information is formatted as a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">origin</td><td>Pointer to the origin vertex. </td></tr>
    <tr><td class="paramname">parkingVertex</td><td>Pointer to the parking spot vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination vertex. </td></tr>
    <tr><td class="paramname">numRoute</td><td>Identifier for multiple routes. </td></tr>
    <tr><td class="paramname">distance</td><td>Total estimated time for the entire trip (driving + walking). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string describing the full route, including driving and walking segments.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O(V), since the function finds the driving and walking routes and reverses the walking route before adding it to the result. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
